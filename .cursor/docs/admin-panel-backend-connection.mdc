# Admin Panel Backend Connection

## Overview
The admin panel has been connected to the Django backend API. All CRUD operations for perfumes now persist to the SQLite database.

## Changes Made

### Frontend (`frontend/src/lib/admin-api.ts`)
1. **Updated API Base URL**: Changed from `/api/admin-data` to Django backend (`http://localhost:8000/api/admin/perfumes/`)
2. **Added Authentication**: All requests include `X-Admin-Key` header for admin authentication
3. **Brand/Collection Handling**: Since backend stores brands/collections as strings (not separate models), the frontend extracts unique values from perfumes
4. **Data Mapping**: Updated to map between frontend structure (with IDs) and backend structure (with string names)
5. **Image Handling**: Images are converted to data URLs and stored in the `images` JSONField array

### Backend (`backend/api/serializers.py`)
1. **Enhanced PerfumeSerializer**: Added support for `notes_top`, `notes_middle`, `notes_base` fields
2. **Custom create/update**: Properly handles notes fields when creating/updating perfumes

### Frontend Admin Pages
1. **Fixed ID References**: Changed `documentId` to `id` to match backend structure
2. **Image Upload**: Updated to use URL strings instead of IDs

## API Endpoints Used

- `GET /api/admin/perfumes/` - List all perfumes
- `POST /api/admin/perfumes/` - Create new perfume
- `GET /api/admin/perfumes/<id>/` - Get perfume details
- `PUT /api/admin/perfumes/<id>/` - Update perfume
- `DELETE /api/admin/perfumes/<id>/` - Delete perfume

## Authentication

The admin panel uses the `X-Admin-Key` header for authentication. Set this in your frontend `.env`:

```env
NEXT_PUBLIC_BACKEND_BASE_URL=http://localhost:8000
NEXT_PUBLIC_ADMIN_KEY=your-admin-key-here
```

This should match the `ADMIN_ACCESS_KEY` in your Django `backend/.env` file.

## Data Structure Mapping

### Frontend → Backend
- `brand` (ID) → `brand` (string name)
- `collection` (ID) → `collection` (string name)
- `notes.top/middle/base` → `notes_top/notes_middle/notes_base` (JSONField arrays)
- `cover` (URL string) → `images` (JSONField array with URL)

### Backend → Frontend
- `brand` (string) → `brand` (object with ID and name)
- `collection` (string) → `collection` (object with ID and name)
- `notes_top/notes_middle/notes_base` → `notes.top/middle/base`
- `images[0]` → `image` (first image URL)

## Limitations

1. **Brands/Collections**: Currently stored as strings in perfumes. Creating/updating brands/collections doesn't persist separately - they're extracted from existing perfumes.

2. **Image Upload**: Currently uses data URLs (base64). For production, implement a proper file upload endpoint that stores images on a CDN or file storage service.

3. **Brand/Collection Management**: The brands and collections admin pages are not fully functional since these are stored as strings, not separate models. Consider creating Brand and Collection models in Django if you need full CRUD for these entities.

## Testing

1. Start Django backend: `cd backend && python manage.py runserver`
2. Start Next.js frontend: `cd frontend && npm run dev`
3. Navigate to `/admin/products` in your browser
4. Create, edit, and delete perfumes - changes should persist in SQLite database

## Future Improvements

1. Create Brand and Collection Django models for proper CRUD
2. Implement file upload endpoint for images (S3, Cloudinary, etc.)
3. Add validation for brand/collection names
4. Add pagination for large perfume lists
5. Add search/filter capabilities in backend
